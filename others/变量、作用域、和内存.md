#### 一、 原始值和引用值
  - 原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。大小固定保存在栈内存上
  - 原始值保存的必须仅仅是一个字面量，引用值保存的是一个对象
  - 值复制时原始值直接复制了一份字面量，而引用值复制的是一个指针
  - 引用值指向的对象保存在全局作用域的堆内存是那个

#### 二、执行上下文和作用域（全局，函数，块级上下文）
  1. 变量或函数的上下文决定了他们可以访问哪些数据
  2. 每一个上下文都有一个关联的变量对象（variable object），这个上下文中定义的所有变量和函数都存在于这个对象上
  3. 全局上下文就是最外层的上下文，在浏览器中全局上下文就是我们所说的window对象
  4. 每个函数调用都有自己的上下文，当代码流进入函数时，函数的上下文被推到一个上下文栈上，在函数执行完成之后，上下文栈会弹出该函数的上下文，将控制权返回给之前的执行上下文，es程序的执行流就是通过这个上下文栈进行控制的
  5. 上下文中的代码在执行的时候会创建一个作用域链（scope chain），这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，代码正在执行的上下文的变量对象始终位于作用域链的最前端。
  6. 如果上下文是函数，则其活动对象用作变量对象。活动对象最初只有一个定义变量：`arguments`
  7. 作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。
  8. **作用域链增强**
     1. try/catch语句的catch块
     2. with语句
  9. 使用var声明变量，变量会被自动添加到最接近的上下文
  10. let声明变量的作用域是块级作用域，let严格来说是也有变量提升的，但是存在暂时性死区

#### 三、垃圾回收
  1. 标记清理
  2. 引用计数（循环引用导致不会被清除）
  3. 内存管理
     1. 通过const和let声明提升性能
     2. 静态分配和对象池
     3. 解除变量的引用有助于垃圾回收



